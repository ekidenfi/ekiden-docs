asyncapi: 3.0.0
info:
  title: Ekiden WebSocket API
  version: 1.0.0
  description: |
    Real-time feeds for market data and account updates.

    ### Flow
    1. Choose environment:
       - Production: `wss://api.ekiden.fi`
       - Staging: `wss://api.staging.ekiden.fi`
    2. Connect to `/ws/public` or `/ws/private` on the chosen host.
    3. Send a **Subscribe** request with dot-separated topics:
       - `orderbook.<depth>.<symbol>` (e.g., `orderbook.1.BTCUSDC`)
       - `trade.<symbol>` (e.g., `trade.BTCUSDC`)
       - `ticker.<symbol>` (e.g., `ticker.BTCUSDC`)
       - `kline.<interval>.<symbol>` (e.g., `kline.1m.BTCUSDC`)
    4. For private data, first send an **Auth** request on `/ws/private`.
    5. Receive **Subscribed** acknowledgement, then streaming **Event** messages.
    6. Use **Unsubscribe** or **Ping** when needed.

servers:
  production:
    host: api.ekiden.fi
    protocol: wss
    description: Production WebSocket endpoint
  staging:
    host: api.staging.ekiden.fi
    protocol: wss
    description: Staging WebSocket endpoint for testing

channels:
  public:
    title: Public
    description: |
      The public channel is used for subscribing to market data.
    address: /ws/public
    messages:
      SubscribeRequest: { $ref: '#/components/messages/SubscribeRequest' }
      UnsubscribeRequest: { $ref: '#/components/messages/UnsubscribeRequest' }
      PingRequest: { $ref: '#/components/messages/PingRequest' }
      Subscribed: { $ref: '#/components/messages/Subscribed' }
      Unsubscribed: { $ref: '#/components/messages/Unsubscribed' }
      Pong: { $ref: '#/components/messages/Pong' }
      Error: { $ref: '#/components/messages/Error' }
      Event: { $ref: '#/components/messages/Event' }
  private:
    title: Private
    description: |
      The private channel is used for subscribing to user-specific data.
    address: /ws/private
    messages:
      AuthRequest: { $ref: '#/components/messages/AuthRequest' }
      AuthResponse: { $ref: '#/components/messages/AuthResponse' }
      SubscribeRequest: { $ref: '#/components/messages/SubscribeRequest' }
      UnsubscribeRequest: { $ref: '#/components/messages/UnsubscribeRequest' }
      PingRequest: { $ref: '#/components/messages/PingRequest' }
      Subscribed: { $ref: '#/components/messages/Subscribed' }
      Unsubscribed: { $ref: '#/components/messages/Unsubscribed' }
      Pong: { $ref: '#/components/messages/Pong' }
      Error: { $ref: '#/components/messages/Error' }
      Event: { $ref: '#/components/messages/Event' }

operations:
  # Client -> Server
  sendSubscribe:   { action: receive, channel: { $ref: '#/channels/public' }, messages: [ { $ref: '#/channels/public/messages/SubscribeRequest' } ] }
  sendUnsubscribe: { action: receive, channel: { $ref: '#/channels/public' }, messages: [ { $ref: '#/channels/public/messages/UnsubscribeRequest' } ] }
  sendPing:        { action: receive, channel: { $ref: '#/channels/public' }, messages: [ { $ref: '#/channels/public/messages/PingRequest' } ] }

  # Server -> Client
  receiveSubscribed:   { action: send, channel: { $ref: '#/channels/public' }, messages: [ { $ref: '#/channels/public/messages/Subscribed' } ] }
  receiveUnsubscribed: { action: send, channel: { $ref: '#/channels/public' }, messages: [ { $ref: '#/channels/public/messages/Unsubscribed' } ] }
  receivePong:         { action: send, channel: { $ref: '#/channels/public' }, messages: [ { $ref: '#/channels/public/messages/Pong' } ] }
  receiveError:        { action: send, channel: { $ref: '#/channels/public' }, messages: [ { $ref: '#/channels/public/messages/Error' } ] }
  receiveEvent:        { action: send, channel: { $ref: '#/channels/public' }, messages: [ { $ref: '#/channels/public/messages/Event' } ] }

  # Client -> Server (private channel)
  sendAuthPrivate:        { action: receive, channel: { $ref: '#/channels/private' }, messages: [ { $ref: '#/channels/private/messages/AuthRequest' } ] }
  sendSubscribePrivate:   { action: receive, channel: { $ref: '#/channels/private' }, messages: [ { $ref: '#/channels/private/messages/SubscribeRequest' } ] }
  sendUnsubscribePrivate: { action: receive, channel: { $ref: '#/channels/private' }, messages: [ { $ref: '#/channels/private/messages/UnsubscribeRequest' } ] }
  sendPingPrivate:        { action: receive, channel: { $ref: '#/channels/private' }, messages: [ { $ref: '#/channels/private/messages/PingRequest' } ] }

  # Server -> Client (private channel)
  receiveAuthPrivate:         { action: send, channel: { $ref: '#/channels/private' }, messages: [ { $ref: '#/channels/private/messages/AuthResponse' } ] }
  receiveSubscribedPrivate:   { action: send, channel: { $ref: '#/channels/private' }, messages: [ { $ref: '#/channels/private/messages/Subscribed' } ] }
  receiveUnsubscribedPrivate: { action: send, channel: { $ref: '#/channels/private' }, messages: [ { $ref: '#/channels/private/messages/Unsubscribed' } ] }
  receivePongPrivate:         { action: send, channel: { $ref: '#/channels/private' }, messages: [ { $ref: '#/channels/private/messages/Pong' } ] }
  receiveErrorPrivate:        { action: send, channel: { $ref: '#/channels/private' }, messages: [ { $ref: '#/channels/private/messages/Error' } ] }
  receiveEventPrivate:        { action: send, channel: { $ref: '#/channels/private' }, messages: [ { $ref: '#/channels/private/messages/Event' } ] }

components:
  messages:
    # Client -> Server
    AuthRequest:
      title: Auth
      description: Authenticate the connection on the private channel using a bearer token (e.g., JWT). Server responds with `AuthResponse`.
      examples:
        - payload:
            op: auth
            bearer: "<JWT>"
            req_id: "200001"
      payload:
        type: object
        additionalProperties: false
        properties:
          op: { type: string, const: auth, default: auth, description: Operation name }
          bearer: { type: string, description: Bearer token issued by the REST authorize endpoint }
          req_id: { type: string, description: Client generated request ID (optional) }
        required: [op, bearer]

    SubscribeRequest:
      title: Subscribe
      description: Subscribe to topics. Server will respond with a `Subscribed` message.
      examples: 
        - payload:
            op: subscribe
            args: ["orderbook.1.BTCUSDC", "trade.BTCUSDC"]
            req_id: "100001"
      payload:
        type: object
        additionalProperties: false
        properties:
          op:
            type: string
            const: "subscribe"
            default: "subscribe"
            description: Operation name
          args:
            type: array
            items:
              type: string
              description: Topic name (e.g., orderbook.1.BTCUSDC, trade.BTCUSDC, ticker.BTCUSDC, kline.1m.BTCUSDC, order, position, execution, account_balance)
            minItems: 1
            uniqueItems: true
            description: List of topics to subscribe to
          req_id:
            type: string
            description: Client generated request ID (optional)
        required: [op, args]

    UnsubscribeRequest:
      title: Unsubscribe
      description: Unsubscribe from topics. Server will respond with an `Unsubscribed` message.
      examples: 
        - payload:
            op: unsubscribe
            args: ["orderbook.1.BTCUSDC"]
            req_id: "100002"
      payload:
        type: object
        additionalProperties: false
        properties:
          op:
            type: string
            const: "unsubscribe"
            default: "unsubscribe"
            description: Operation name
          args:
            type: array
            items:
              type: string
            minItems: 1
            uniqueItems: true
            description: List of topics to unsubscribe from
          req_id:
            type: string
            description: Client generated request ID (optional)
        required: [op, args]

    PingRequest:
      title: Ping
      description: Ping the server. The server will respond with a `Pong` message. Client can use `ts` to measure RTT.
      examples: 
        - payload:
            op: ping
            ts: 1681234567890123114
            req_id: "100003"
      payload:
        type: object
        additionalProperties: false
        properties:
          op:
            type: string
            const: "ping"
            default: "ping"
            description: Operation name
          ts:
            type: integer
            description: Client timestamp in unix nanoseconds (optional)
          req_id:
            type: string
            description: Client generated request ID (optional)
        required: [op]

    # Server -> Client acks
    AuthResponse:
      title: Auth
      description: Response to an `Auth` request. Indicates whether authentication succeeded.
      examples:
        - payload:
            op: auth
            success: true
            user_id: "0x88a70ff..."
            req_id: "200001"
        - payload:
            op: auth
            success: false
            message: "INVALID_TOKEN"
            req_id: "200001"
      payload:
        type: object
        additionalProperties: false
        properties:
          op: { type: string, const: auth, default: auth, description: Operation name }
          success: { type: boolean, description: Authentication result }
          user_id: { type: string, description: User identifier when authenticated (optional) }
          message: { type: string, description: Error message when authentication fails (optional) }
          req_id: { type: string, description: Client generated request ID (optional) }
        required: [op, success]

    Subscribed:
      title: Subscribed
      description: Acknowledgement for a successful `Subscribe` request. Echoes the list of topics.
      examples:
        - payload:
            op: subscribed
            args: ["orderbook.1.BTCUSDC"]
            req_id: "100001"
      payload:
        type: object
        properties:
          op: { type: string, const: subscribed, description: Operation name }
          args:
            type: array
            items: { type: string }
            minItems: 1
            uniqueItems: true
            description: List of topics subscribed to
          req_id: { type: string, description: Client generated request ID (optional) }
        required: [op, args]

    Unsubscribed:
      title: Unsubscribed
      description: Acknowledgement for a successful `Unsubscribe` request. Echoes the list of topics.
      examples:
        - payload:
            op: unsubscribed
            args: ["orderbook.1.BTCUSDC"]
            req_id: "100002"
      payload:
        type: object
        properties:
          op: { type: string, const: unsubscribed, description: Operation name }
          args:
            type: array
            items: { type: string }
            minItems: 1
            uniqueItems: true
            description: List of topics unsubscribed from
          req_id: { type: string, description: Client generated request ID (optional) }
        required: [op, args]

    Pong:
      title: Pong
      description: Heartbeat response to a `Ping` request. Includes the server timestamp in nanoseconds and echoes `client_ts` to help client measure RTT.
      examples:
        - payload:
            op: pong
            req_id: "100003"
            client_ts: 1681234567890123114
            server_ts: 1681234567890123456
      payload:
        type: object
        properties:
          op: { type: string, const: pong, description: Operation name }
          req_id: { type: string, description: Client generated request ID (optional) }
          client_ts: { type: integer, description: Client timestamp in unix nanoseconds (optional) }
          server_ts: { type: integer, description: Server timestamp in unix nanoseconds }
        required: [op, server_ts]

    Error:
      title: Error
      description: Standard error response for invalid requests, authorization failures, or policy violations (e.g., rate limits).
      examples:
        - payload:
            op: error
            message: "Invalid topic format: ticker. Expected one of: trade.<symbol>, orderbook.<depth>.<symbol>..."
            req_id: "100004"
      payload:
        type: object
        properties:
          op: { type: string, const: error, description: Operation name }
          message: { type: string, description: Error message }
          req_id: { type: string, description: Client generated request ID (optional) }
        required: [op, message]

    # # Server -> Client event (single envelope with variants)
    # Event:
    #   title: Event
    #   description: |
    #     Unified event envelope. `data` can be one of public market updates or private user updates.
    #   examples:
    #     - payload:
    #         op: event
    #         server_ts_ms: 1681234567890
    #         topic: "orderbook.1.BTCUSDC"
    #         type: "snapshot"
    #         data:
    #           s: "BTCUSDC"
    #           ts: 1681234567890
    #           b: [ ["100.1", "5"] ]
    #           a: [ ["100.2", "3"] ]
    #           u: 123
    #           seq: 21
    #           mts: 1681234567880
    #   payload:
    #     type: object
    #     properties:
    #       op: { type: string, const: event, description: Operation name }
    #       server_ts_ms: { type: integer, description: Server timestamp in milliseconds }
    #       topic: { type: string, description: Topic name }
    #       oneOf:
    #         - $ref: '#/components/messages/OrderbookEvent'
    #         - $ref: '#/components/messages/TradeEvent'
    #         - $ref: '#/components/messages/TickerEvent'
    #         - $ref: '#/components/messages/KlineEvent'
    #         - $ref: '#/components/messages/OrderEvent'
    #         - $ref: '#/components/messages/ExecutionEvent'
    #         - $ref: '#/components/messages/PositionEvent'
    #         - $ref: '#/components/messages/AccountBalanceEvent'
    #     required: [op, server_ts_ms, topic]

    # Event Variants
    OrderbookEvent:
      payload:
        type: object
        properties:
          type: { type: string, enum: [snapshot, delta] }
          data: { $ref: '#/components/schemas/OrderBookSnapshot' }
        required: [type, data]

    TradeEvent:
      payload:
        type: object
        properties:
          data: { type: array, items: { $ref: '#/components/schemas/PublicTrade' } }
        required: [data]

    TickerEvent:
      payload:
        type: object
        properties:
          data: { $ref: '#/components/schemas/TickerSnapshot' }
        required: [data]

    KlineEvent:
      payload:
        type: object
        properties:
          data: { $ref: '#/components/schemas/KlineSnapshot' }
        required: [data]

    OrderEvent:
      payload:
        type: object
        properties:
          data: { type: array, items: { $ref: '#/components/schemas/Order' } }
        required: [data]

    ExecutionEvent:
      payload:
        type: object
        properties:
          data: { type: array, items: { $ref: '#/components/schemas/Execution' } }
        required: [data]

    PositionEvent:
      payload:
        type: object
        properties:
          data: { type: array, items: { $ref: '#/components/schemas/Position' } }
        required: [data]

    AccountBalanceEvent:
      payload:
        type: object
        properties:
          data: { $ref: '#/components/schemas/AccountBalance' }
        required: [data]

  schemas:
    # Public event schemas
    OrderBookSnapshot:
      type: object
      properties:
        s: { type: string, description: Symbol }
        ts: { type: integer, description: Timestamp (ms) }
        b: { type: array, items: { $ref: '#/components/schemas/OrderBookLevel' }, description: Bids }
        a: { type: array, items: { $ref: '#/components/schemas/OrderBookLevel' }, description: Asks }
        u: { type: integer, description: Update ID }
        seq: { type: integer, description: Sequence }
        mts: { type: integer, description: Matching timestamp (ms) }
      required: [s, ts, b, a, u, seq, mts]

    OrderBookLevel:
      type: array
      items: { type: string }
      minItems: 2
      maxItems: 2
      description: "[price, size]"

    PublicTrade:
      type: object
      properties:
        i: { type: string, description: Trade ID }
        s: { type: string, description: Symbol }
        S: { type: string, enum: [Buy, Sell], description: Side }
        v: { type: string, description: Size }
        p: { type: string, description: Price }
        seq: { type: integer, description: Sequence }
        T: { type: integer, description: Trade time (ms) }
      required: [i, s, S, v, p, seq, T]

    TickerSnapshot:
      type: object
      properties:
        symbol: { type: string }
        addr: { type: string }
        last_price: { type: string }
        index_price: { type: string }
        mark_price: { type: string }
        prev_price_24h: { type: string }
        high_price_24h: { type: string }
        low_price_24h: { type: string }
        prev_price_1h: { type: string }
        volume_24h: { type: string }
        turnover_24h: { type: string }
        open_interest: { type: string }
        open_interest_value: { type: string }
        funding_rate: { type: string }
        next_funding_time: { type: integer, description: Next funding time (ms) }
        best_ask_size: { type: string }
        best_ask_price: { type: string }
        best_bid_size: { type: string }
        best_bid_price: { type: string }
      required: [symbol, addr, last_price, mark_price]

    KlineSnapshot:
      type: object
      properties:
        t: { type: integer, description: Open time (ms) }
        i: { type: string, description: Interval }
        o: { type: string, description: Open price }
        h: { type: string, description: High price }
        l: { type: string, description: Low price }
        c: { type: string, description: Close price }
        T: { type: integer, description: Close time (ms) }
        v: { type: string, description: Volume }
        n: { type: string, description: Trade count }
      required: [t, i, o, h, l, c, T, v, n]

    # Private event schemas
    Order:
      type: object
      properties:
        order_id: { type: string }
        order_link_id: { type: string, nullable: true }
        symbol: { type: string }
        sub_account_address: { type: string }
        price: { type: string }
        qty: { type: string }
        side: { type: string }
        margin_mode: { type: string }
        order_status: { type: string }
        avg_price: { type: string }
        leaves_qty: { type: string }
        cum_exec_qty: { type: string }
        cum_exec_value: { type: string }
        cum_exec_fee: { type: string }
        created_time: { type: integer }
        updated_time: { type: integer }
      required: [order_id, symbol, sub_account_address, price, qty, side, order_status]

    Execution:
      type: object
      properties:
        exec_id: { type: string }
        symbol: { type: string }
        order_id: { type: string }
        side: { type: string }
        sub_account_address: { type: string }
        exec_price: { type: string }
        exec_qty: { type: string }
        exec_value: { type: string }
        exec_type: { type: string }
        exec_time: { type: integer }
        is_maker: { type: boolean }
        fee_rate: { type: string }
        seq: { type: integer }
      required: [exec_id, symbol, order_id, side, sub_account_address, exec_price, exec_qty, exec_time]

    Position:
      type: object
      properties:
        symbol: { type: string }
        sub_account_address: { type: string }
        side: { type: string }
        size: { type: string }
        avg_price: { type: string }
        position_value: { type: string }
        leverage: { type: string }
        mark_price: { type: string }
        unrealized_pnl: { type: string }
        realized_pnl_cum: { type: string }
        updated_time: { type: integer }
        seq: { type: integer }
      required: [symbol, sub_account_address, side, size, avg_price]

    AccountBalance:
      type: object
      properties:
        sub_account_address: { type: string }
        equity: { type: string }
        vault_balance: { type: string }
        margin_balance: { type: string }
        available_balance: { type: string }
        unrealised_pnl: { type: string }
      required: [sub_account_address, equity, vault_balance, margin_balance, available_balance] 
